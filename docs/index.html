
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <link rel="shortcut icon" href="favicon.ico">
  <title>compound.core - api docs</title>
  <script src="js/highlight.min.js"></script>
  <script src="js/gumshoe.min.js"></script>
  <script src="js/smooth-scroll.min.js"></script>
  
  <!-- CSS -->
  <link rel="stylesheet" href="css/poole.css">
  <link rel="stylesheet" href="css/syntax.css">
  <link rel="stylesheet" href="css/lanyon.css">
  <link rel="stylesheet" href="css/bolton.css">
  <link rel="stylesheet" href="css/bolton-api.css">
  <link rel="stylesheet" href="css/bolton-highlight.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">
  
</head>

  <body class="theme-base-08">
    <span id="page-top"></span>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <nav class="sidebar-nav">
    <span>&nbsp;</span>
    <a class="sidebar-nav-item header" href="index.html"><img src="img/compound_small.png"/></a>
    <span>&nbsp;</span>
    
    <span class="sidebar-nav-item">&nbsp;</span>
    <span class="sidebar-nav-item">&nbsp;</span>
  </nav>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <span>compound.core</span>
            <small>api docs</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="page">
          <div class="heading">
            <div>
              <h5>Author: Daniel Neal&nbsp;&nbsp;<a href="mailto:danielneal@riverford.co.uk">(danielneal@riverford.co.uk)</a></h5>
              <h5>Date: 26 January 2018</h5>
              <h5>Repository: <a href="https://github.com/riverford/compound">https://github.com/riverford/compound</a></h5>
              <h5>Version: 2018.01.26-2-flat</h5></div></div>
          <hr/>
          <div class="outline">
            <div class="toc">
              <nav data-gumshoe-header>
                <ul data-gumshoe>
                  <a data-scroll class="top" href="#page-top">TOP</a>
                  <li><a class="chapter" data-scroll="" href="#getting-started"><h4>1 &nbsp; Getting started</h4></a></li><li><a class="chapter" data-scroll="" href="#operating-on-the-compound"><h4>2 &nbsp; Operating on the compound</h4></a><a class="section" data-scroll="" href="#adding"><h5><i>2.1 &nbsp; Adding</i></h5></a><a class="section" data-scroll="" href="#removing"><h5><i>2.2 &nbsp; Removing</i></h5></a><a class="section" data-scroll="" href="#reading"><h5><i>2.3 &nbsp; Reading</i></h5></a></li><li><a class="chapter" data-scroll="" href="#secondary-indexes"><h4>3 &nbsp; Secondary indexes</h4></a><a class="section" data-scroll="" href="#one-to-many"><h5><i>3.1 &nbsp; One to many</i></h5></a><a class="section" data-scroll="" href="#one-to-one"><h5><i>3.2 &nbsp; One to one</i></h5></a><a class="section" data-scroll="" href="#many-to-one"><h5><i>3.3 &nbsp; Many to one</i></h5></a><a class="section" data-scroll="" href="#many-to-many"><h5><i>3.4 &nbsp; Many to many</i></h5></a><a class="section" data-scroll="" href="#composite-indexes"><h5><i>3.5 &nbsp; Composite indexes</i></h5></a></li><li><a class="chapter" data-scroll="" href="#handling-conflict"><h4>4 &nbsp; Handling conflict</h4></a><a class="section" data-scroll="" href="#replace"><h5><i>4.1 &nbsp; Replace</i></h5></a><a class="section" data-scroll="" href="#throw"><h5><i>4.2 &nbsp; Throw</i></h5></a><a class="section" data-scroll="" href="#merge"><h5><i>4.3 &nbsp; Merge</i></h5></a><a class="section" data-scroll="" href="#custom"><h5><i>4.4 &nbsp; Custom</i></h5></a></li><li><a class="chapter" data-scroll="" href="#Extension"><h4>5 &nbsp; Extension</h4></a><a class="section" data-scroll="" href="#custom-keys"><h5><i>5.1 &nbsp; Custom keys</i></h5></a><a class="section" data-scroll="" href="#custom-conflict"><h5><i>5.2 &nbsp; Custom conflict behaviour</i></h5></a><a class="section" data-scroll="" href="#custom-indexes"><h5><i>5.3 &nbsp; Custom indexes</i></h5></a></li><li><a class="chapter" data-scroll="" href="#miscellaneous"><h4>6 &nbsp; Miscellaneous</h4></a><a class="section" data-scroll="" href="#paths-as-keys"><h5><i>6.1 &nbsp; Paths as keys</i></h5></a><a class="section" data-scroll="" href="#diffing"><h5><i>6.2 &nbsp; Diffing</i></h5></a><a class="section" data-scroll="" href="#experimental-alternate-structure"><h5><i>6.3 &nbsp; (experimental) Alternate structure</i></h5></a></li>
                </ul>
              </nav>
            </div>
          </div>

          <div class="toc">
              <nav>
                <ul>
                  <li><a class="chapter" data-scroll="" href="#getting-started"><h4>1 &nbsp; Getting started</h4></a></li><li><a class="chapter" data-scroll="" href="#operating-on-the-compound"><h4>2 &nbsp; Operating on the compound</h4></a><a class="section" data-scroll="" href="#adding"><h5><i>2.1 &nbsp; Adding</i></h5></a><a class="section" data-scroll="" href="#removing"><h5><i>2.2 &nbsp; Removing</i></h5></a><a class="section" data-scroll="" href="#reading"><h5><i>2.3 &nbsp; Reading</i></h5></a></li><li><a class="chapter" data-scroll="" href="#secondary-indexes"><h4>3 &nbsp; Secondary indexes</h4></a><a class="section" data-scroll="" href="#one-to-many"><h5><i>3.1 &nbsp; One to many</i></h5></a><a class="section" data-scroll="" href="#one-to-one"><h5><i>3.2 &nbsp; One to one</i></h5></a><a class="section" data-scroll="" href="#many-to-one"><h5><i>3.3 &nbsp; Many to one</i></h5></a><a class="section" data-scroll="" href="#many-to-many"><h5><i>3.4 &nbsp; Many to many</i></h5></a><a class="section" data-scroll="" href="#composite-indexes"><h5><i>3.5 &nbsp; Composite indexes</i></h5></a></li><li><a class="chapter" data-scroll="" href="#handling-conflict"><h4>4 &nbsp; Handling conflict</h4></a><a class="section" data-scroll="" href="#replace"><h5><i>4.1 &nbsp; Replace</i></h5></a><a class="section" data-scroll="" href="#throw"><h5><i>4.2 &nbsp; Throw</i></h5></a><a class="section" data-scroll="" href="#merge"><h5><i>4.3 &nbsp; Merge</i></h5></a><a class="section" data-scroll="" href="#custom"><h5><i>4.4 &nbsp; Custom</i></h5></a></li><li><a class="chapter" data-scroll="" href="#Extension"><h4>5 &nbsp; Extension</h4></a><a class="section" data-scroll="" href="#custom-keys"><h5><i>5.1 &nbsp; Custom keys</i></h5></a><a class="section" data-scroll="" href="#custom-conflict"><h5><i>5.2 &nbsp; Custom conflict behaviour</i></h5></a><a class="section" data-scroll="" href="#custom-indexes"><h5><i>5.3 &nbsp; Custom indexes</i></h5></a></li><li><a class="chapter" data-scroll="" href="#miscellaneous"><h4>6 &nbsp; Miscellaneous</h4></a><a class="section" data-scroll="" href="#paths-as-keys"><h5><i>6.1 &nbsp; Paths as keys</i></h5></a><a class="section" data-scroll="" href="#diffing"><h5><i>6.2 &nbsp; Diffing</i></h5></a><a class="section" data-scroll="" href="#experimental-alternate-structure"><h5><i>6.3 &nbsp; (experimental) Alternate structure</i></h5></a></li>
                </ul>
              </nav>
          </div>
          <div class="code"><pre><code class="clojure">(st/instrument)
(s/check-asserts true)</code></pre></div><div><span id="getting-started"></span><h2><b>1 &nbsp;&nbsp; Getting started</b></h2></div><div class="code"><pre><code class="clojure">(require '[compound.core :as c])</code></pre></div><div><p>We're gonna have to handle a lot of fruit today. We should probably set up somewhere to store all the information about it.</p></div><div class="code"><pre><code class="clojure">(c/compound {:primary-index-def {:key :id}}) =&gt;
  
{:primary-index-def {:key :id
                     :on-conflict :compound/replace},
 :primary-index {},
 :secondary-indexes-by-id {},
 :secondary-index-defs-by-id {}}</code></pre></div><div><span id="operating-on-the-compound"></span><h2><b>2 &nbsp;&nbsp; Operating on the compound</b></h2></div><div><span id="adding"></span><h3>2.1 &nbsp;&nbsp; Adding</h3></div><div><p>This compound is a feeling a bit empty, time to add some data.</p></div><div class="code"><pre><code class="clojure">(-&gt; (c/compound {:primary-index-def {:key :id}})
    (c/add-items [{:id 1 :name &quot;bananoes&quot;}
                  {:id 2 :name &quot;grapes&quot;}
                  {:id 3 :name &quot;tomatoes&quot;}])) =&gt;

{:primary-index-def {:on-conflict :compound/replace, :key :id},
 :primary-index {1 {:id 1, :name &quot;bananoes&quot;},
                 2 {:id 2, :name &quot;grapes&quot;},
                 3 {:id 3, :name &quot;tomatoes&quot;}},
 :secondary-indexes-by-id {},
 :secondary-index-defs-by-id {}}</code></pre></div><div><span id="removing"></span><h3>2.2 &nbsp;&nbsp; Removing</h3></div><div><p>Wait, what are bananoes?? Let's get rid of them.</p></div><div class="code"><pre><code class="clojure">(-&gt; (c/compound {:primary-index-def {:key :id}})
    (c/add-items [{:id 1 :name &quot;bananoes&quot;}
                  {:id 2 :name &quot;grapes&quot;}
                  {:id 3 :name &quot;tomatoes&quot;}])
    (c/remove-keys [1])) =&gt;
  
{:primary-index-def {:on-conflict :compound/replace, :key :id},
 :primary-index {3 {:id 3, :name &quot;tomatoes&quot;},
                 2 {:id 2, :name &quot;grapes&quot;}},
 :secondary-indexes-by-id {},
 :secondary-index-defs-by-id {}}</code></pre></div><div><span id="reading"></span><h3>2.3 &nbsp;&nbsp; Reading</h3></div><div><p>Looking at the whole data structure every time is a bit visually distracting.</p></div><div><p>Get all the indexes using <code>indexes-by-id</code>, and particular indexes using <code>index</code></p></div><div class="code"><pre><code class="clojure">(-&gt; (c/compound {:primary-index-def {:key :id}})
    (c/add-items [{:id 1 :name &quot;bananoes&quot;}
                  {:id 2 :name &quot;grapes&quot;}
                  {:id 3 :name &quot;tomatoes&quot;}])
    (c/remove-keys [1])
    (c/indexes-by-id)) =&gt;

{:id {3 {:id 3, :name &quot;tomatoes&quot;},
      2 {:id 2, :name &quot;grapes&quot;}}}</code></pre></div><div class="code"><pre><code class="clojure">(-&gt; (c/compound {:primary-index-def {:key :id}})
    (c/add-items [{:id 1 :name &quot;bananoes&quot;}
                  {:id 2 :name &quot;grapes&quot;}
                  {:id 3 :name &quot;tomatoes&quot;}])
    (c/remove-keys [1])
    (c/index :id)) =&gt;

{3 {:id 3, :name &quot;tomatoes&quot;},
 2 {:id 2, :name &quot;grapes&quot;}}</code></pre></div><div><p>Because these built in indexes are just maps, we can operate on them using standard clojure functions</p></div><div class="code"><pre><code class="clojure">(-&gt; (c/compound {:primary-index-def {:key :id}})
    (c/add-items [{:id 1 :name &quot;bananoes&quot;}
                  {:id 2 :name &quot;grapes&quot;}
                  {:id 3 :name &quot;tomatoes&quot;}])
    (c/remove-keys [1])
    (c/index :id)
    (get 2)) =&gt;
  
{:id 2, :name &quot;grapes&quot;}</code></pre></div><div><p>Isn't that just grapes!</p></div><div><span id="secondary-indexes"></span><h2><b>3 &nbsp;&nbsp; Secondary indexes</b></h2></div><div><p>Looking up fruit by id is all well and good, but what if we want to be able to find all fruits of a certain colour, to make a seasonal display? </p></div><div><p>We'll need to add a secondary index, on <code>:colour</code>.</p></div><div class="code"><pre><code class="clojure">(-&gt; (c/compound {:primary-index-def {:key :id}
                 :secondary-index-defs [{:key :colour}]})
    (c/add-items [{:id 1 :name &quot;grapes&quot; :colour &quot;green&quot;}
                  {:id 2 :name &quot;bananas&quot; :colour &quot;yellow&quot;}])
    (c/indexes-by-id)) =&gt;
  
{:colour
 {&quot;green&quot; #{{:id 1, :name &quot;grapes&quot;, :colour &quot;green&quot;}},
  &quot;yellow&quot; #{{:id 2, :name &quot;bananas&quot;, :colour &quot;yellow&quot;}}},
 :id
 {1 {:id 1, :name &quot;grapes&quot;, :colour &quot;green&quot;},
  2 {:id 2, :name &quot;bananas&quot;, :colour &quot;yellow&quot;}}}</code></pre></div><div><p><em>Note: secondary indexes don't have to be added at construction time. Adding them later will index all of the items currently in the compound into the new secondary index.</em></p></div><div class="code"><pre><code class="clojure">(-&gt; (c/compound {:primary-index-def {:key :id}})
    (c/add-items [{:id 1 :name &quot;grapes&quot; :colour &quot;green&quot;}
                  {:id 2 :name &quot;bananas&quot; :colour &quot;yellow&quot;}])
    (c/add-secondary-index {:key :colour})
    (c/indexes-by-id)) =&gt;
  
{:colour
 {&quot;green&quot; #{{:id 1, :name &quot;grapes&quot;, :colour &quot;green&quot;}},
  &quot;yellow&quot; #{{:id 2, :name &quot;bananas&quot;, :colour &quot;yellow&quot;}}},
 :id
 {1 {:id 1, :name &quot;grapes&quot;, :colour &quot;green&quot;},
  2 {:id 2, :name &quot;bananas&quot;, :colour &quot;yellow&quot;}}}</code></pre></div><div><p>There are a bunch of different index types built in, to cover common use cases</p></div><div><span id="one-to-many"></span><h3>3.1 &nbsp;&nbsp; One to many</h3></div><div><p>The one to many index is used when there may be more than one item with the same <code>:key</code>. The index is a map with a set for each key value.</p></div><div><p><em>Note: this is also, the default secondary index type if the <code>:index-type</code> is not specified.</em></p></div><div class="code"><pre><code class="clojure">(-&gt; (c/compound {:primary-index-def {:key :id}
                 :secondary-index-defs [{:key :colour
                                         :index-type :compound/one-to-many}]})
    (c/add-items [{:id 1 :name &quot;grapes&quot; :colour &quot;green&quot;}
                  {:id 2 :name &quot;bananas&quot; :colour &quot;yellow&quot;}])
    (c/indexes-by-id)) =&gt;
  
{:colour
 {&quot;green&quot; #{{:id 1, :name &quot;grapes&quot;, :colour &quot;green&quot;}},
  &quot;yellow&quot; #{{:id 2, :name &quot;bananas&quot;, :colour &quot;yellow&quot;}}},
 :id
 {1 {:id 1, :name &quot;grapes&quot;, :colour &quot;green&quot;},
  2 {:id 2, :name &quot;bananas&quot;, :colour &quot;yellow&quot;}}}</code></pre></div><div><span id="one-to-one"></span><h3>3.2 &nbsp;&nbsp; One to one</h3></div><div><p>The one to one index is used when there can only be one item for each <code>:key</code>. An error is thrown if an item with a duplicate key is added without first removing the existing one</p></div><div class="code"><pre><code class="clojure">(-&gt; (c/compound {:primary-index-def {:key :id}
                 :secondary-index-defs [{:key :name
                                         :index-type :compound/one-to-one}]})
    (c/add-items [{:id 1 :name &quot;grapes&quot; :colour &quot;green&quot;}
                  {:id 2 :name &quot;bananas&quot; :colour &quot;yellow&quot;}])
    (c/indexes-by-id)) =&gt;
  
{:name
 {&quot;grapes&quot; {:id 1, :name &quot;grapes&quot;, :colour &quot;green&quot;},
  &quot;bananas&quot; {:id 2, :name &quot;bananas&quot;, :colour &quot;yellow&quot;}},
 :id
 {1 {:id 1, :name &quot;grapes&quot;, :colour &quot;green&quot;},
  2 {:id 2, :name &quot;bananas&quot;, :colour &quot;yellow&quot;}}}</code></pre></div><div><span id="many-to-one"></span><h3>3.3 &nbsp;&nbsp; Many to one</h3></div><div><p>The many to one index is used when there an item's <code>:key</code> can have multiple values, but each value can occur at most once</p></div><div class="code"><pre><code class="clojure">(-&gt; (c/compound {:primary-index-def {:key :id}
                 :secondary-index-defs [{:key :aka
                                         :index-type :compound/many-to-one}]})
    (c/add-items [{:id 1 :name &quot;grapes&quot; :colour &quot;green&quot; :aka #{&quot;green bunches of joy&quot;}}
                  {:id 2 :name &quot;bananas&quot; :colour &quot;yellow&quot; :aka #{&quot;yellow boomerangs&quot; &quot;monkey nourishers&quot;}}])
    (c/indexes-by-id)) =&gt;

{:aka
 {&quot;monkey nourishers&quot;
  {:id 2,
   :name &quot;bananas&quot;,
   :colour &quot;yellow&quot;,
   :aka #{&quot;monkey nourishers&quot; &quot;yellow boomerangs&quot;}},
  &quot;yellow boomerangs&quot;
  {:id 2,
   :name &quot;bananas&quot;,
   :colour &quot;yellow&quot;,
   :aka #{&quot;monkey nourishers&quot; &quot;yellow boomerangs&quot;}},
  &quot;green bunches of joy&quot;
  {:id 1, :name &quot;grapes&quot;, :colour &quot;green&quot;, :aka #{&quot;green bunches of joy&quot;}}},
 :id
 {1 {:id 1, :name &quot;grapes&quot;, :colour &quot;green&quot;, :aka #{&quot;green bunches of joy&quot;}},
  2
  {:id 2,
   :name &quot;bananas&quot;,
   :colour &quot;yellow&quot;,
   :aka #{&quot;monkey nourishers&quot; &quot;yellow boomerangs&quot;}}}}</code></pre></div><div><span id="many-to-many"></span><h3>3.4 &nbsp;&nbsp; Many to many</h3></div><div><p>The many to many index is used when there an item's <code>:key</code> can have multiple values, and each value can occur multiple times</p></div><div><p>What goes with cheese?</p></div><div class="code"><pre><code class="clojure">(-&gt; (c/compound {:primary-index-def {:key :id}
                 :secondary-index-defs [{:key :goes-with
                                         :index-type :compound/many-to-many}]})
    (c/add-items [{:id 1 :name &quot;grapes&quot; :colour &quot;green&quot; :goes-with #{&quot;cheese&quot;}}
                  {:id 2 :name &quot;figs&quot; :colour &quot;green&quot; :goes-with #{&quot;cheese&quot; &quot;ice cream&quot;}}
                  {:id 3 :name &quot;bananas&quot; :colour &quot;yellow&quot; :goes-with #{&quot;pancakes&quot; &quot;ice cream&quot;}}])
    (c/index :goes-with)
    (get &quot;cheese&quot;)) =&gt;

#{{:id 2, :name &quot;figs&quot;, :colour &quot;green&quot;, :goes-with #{&quot;ice cream&quot; &quot;cheese&quot;}}
  {:id 1, :name &quot;grapes&quot;, :colour &quot;green&quot;, :goes-with #{&quot;cheese&quot;}}}</code></pre></div><div><p>(the answer is not bananas)</p></div><div><span id="composite-indexes"></span><h3>3.5 &nbsp;&nbsp; Composite indexes</h3></div><div><p>Composite indexes are useful when you want to index something by this <em>then</em> by <em>that</em></p></div><div><p>They require <code>:keys</code>to be a sequence of keys</p></div><div><span id="one-to-many-composite"></span><h3><i>3.5.1 &nbsp;&nbsp; One to many (composite)</i></h3></div><div class="code"><pre><code class="clojure">(-&gt; (c/compound {:primary-index-def {:key :id}
                 :secondary-index-defs [{:keys [:colour :category]
                                         :index-type :compound/one-to-many-composite}]})
    (c/add-items [{:id 1 :name &quot;grapes&quot; :colour &quot;green&quot; :category &quot;berries&quot;}
                  {:id 2 :name &quot;sloe&quot; :colour &quot;blue&quot; :category &quot;berries&quot;}
                  {:id 3 :name &quot;orange&quot; :colour &quot;orange&quot; :category &quot;citrus&quot;}
                  {:id 4 :name &quot;lemon&quot; :colour &quot;yellow&quot; :category &quot;citrus&quot;}
                  {:id 5 :name &quot;lime&quot; :colour &quot;green&quot; :category &quot;citrus&quot;}])
    (c/index [:colour :category])) =&gt;

{&quot;orange&quot; {&quot;citrus&quot; #{{:id 3, :name &quot;orange&quot;, :colour &quot;orange&quot;, :category &quot;citrus&quot;}}},
 &quot;green&quot; {&quot;berries&quot; #{{:id 1, :name &quot;grapes&quot;, :colour &quot;green&quot;, :category &quot;berries&quot;}},
          &quot;citrus&quot; #{{:id 5, :name &quot;lime&quot;, :colour &quot;green&quot;, :category &quot;citrus&quot;}}},
 &quot;yellow&quot; {&quot;citrus&quot; #{{:id 4, :name &quot;lemon&quot;, :colour &quot;yellow&quot;, :category &quot;citrus&quot;}}},
 &quot;blue&quot; {&quot;berries&quot; #{{:id 2, :name &quot;sloe&quot;, :colour &quot;blue&quot;, :category &quot;berries&quot;}}}}</code></pre></div><div><span id="one-to-one-composite"></span><h3><i>3.5.2 &nbsp;&nbsp; One to one (composite)</i></h3></div><div class="code"><pre><code class="clojure">(-&gt; (c/compound {:primary-index-def {:key :id}
                 :secondary-index-defs [{:keys [:category :display-index]
                                         :index-type :compound/one-to-one-composite}]})
    (c/add-items [{:id 1 :name &quot;grapes&quot; :display-index 1 :category &quot;berries&quot;}
                  {:id 2 :name &quot;sloe&quot; :display-index 2 :category &quot;berries&quot;}
                  {:id 3 :name &quot;orange&quot; :display-index 1 :category &quot;citrus&quot;}
                  {:id 4 :name &quot;lemon&quot; :display-index 2 :category &quot;citrus&quot;}
                  {:id 5 :name &quot;lime&quot; :display-index 3 :category &quot;citrus&quot;}])
    (c/index [:category :display-index])) =&gt;

{&quot;berries&quot;
 {1 {:id 1, :name &quot;grapes&quot;, :display-index 1, :category &quot;berries&quot;},
  2 {:id 2, :name &quot;sloe&quot;, :display-index 2, :category &quot;berries&quot;}},
 &quot;citrus&quot;
 {2 {:id 4, :name &quot;lemon&quot;, :display-index 2, :category &quot;citrus&quot;},
  3 {:id 5, :name &quot;lime&quot;, :display-index 3, :category &quot;citrus&quot;},
  1 {:id 3, :name &quot;orange&quot;, :display-index 1, :category &quot;citrus&quot;}}}</code></pre></div><div><span id="handling-conflict"></span><h2><b>4 &nbsp;&nbsp; Handling conflict</b></h2></div><div><p>Sometimes we need more control over what happens when we add an item with a key that already exists. Compound some built in behaviour and an extension point for customisation.</p></div><div><span id="replace"></span><h3>4.1 &nbsp;&nbsp; Replace</h3></div><div><p>Using <code>:compound/replace</code> for <code>:on-conflict</code> will resolve conflicts by removing the previous item with that key from the primary index and all secondary indexes before adding the new item</p></div><div class="code"><pre><code class="clojure">(-&gt; (c/compound {:primary-index-def {:key :id
                                     :on-conflict :compound/replace}
                 :secondary-index-defs [{:key :name}]})
    (c/add-items [{:id 1 :name &quot;bananas&quot;}
                  {:id 2 :name &quot;grapes&quot;}
                  {:id 3 :name &quot;tomatoes&quot;}
                  {:id 3 :name &quot;oranges&quot;}])
    (c/indexes-by-id)) =&gt;

{:name
 {&quot;grapes&quot; #{{:id 2, :name &quot;grapes&quot;}},
  &quot;oranges&quot; #{{:id 3, :name &quot;oranges&quot;}},
  &quot;bananas&quot; #{{:id 1, :name &quot;bananas&quot;}}},
 :id
 {1 {:id 1, :name &quot;bananas&quot;},
  2 {:id 2, :name &quot;grapes&quot;},
  3 {:id 3, :name &quot;oranges&quot;}}}</code></pre></div><div><span id="throw"></span><h3>4.2 &nbsp;&nbsp; Throw</h3></div><div><p>Using <code>:compound/throw</code> for <code>:on-conflict</code> will throw an error if we try and add an item with a key that already exists</p></div><div class="code"><pre><code class="clojure">(-&gt; (c/compound {:primary-index-def {:key :id
                                     :on-conflict :compound/throw}
                 :secondary-index-defs [{:key :name}]})
    (c/add-items [{:id 1 :name &quot;bananas&quot;}
                  {:id 2 :name &quot;grapes&quot;}
                  {:id 3 :name &quot;tomatoes&quot;}
                  {:id 3 :name &quot;oranges&quot;}])
    (c/indexes-by-id))
=&gt; (throws-info {:existing-item {:id 3 :name &quot;tomatoes&quot;}
                 :new-item {:id 3 :name &quot;oranges&quot;}})</code></pre></div><div><span id="merge"></span><h3>4.3 &nbsp;&nbsp; Merge</h3></div><div><p>Using <code>:compound/merge</code> for <code>:on-conflict</code> will call <code>clojure.core/merge</code> on the previous item and the new item when the key already exists</p></div><div class="code"><pre><code class="clojure">(-&gt; (c/compound {:primary-index-def {:key :id
                                     :on-conflict :compound/merge}
                 :secondary-index-defs [{:key :name}]})
    (c/add-items [{:id 1 :name &quot;bananas&quot;}
                  {:id 2 :name &quot;grapes&quot;}
                  {:id 3 :name &quot;tomatoes&quot;}
                  {:id 3 :colour &quot;red&quot;}])
    (c/indexes-by-id)) =&gt;
  
{:name
 {&quot;grapes&quot; #{{:id 2, :name &quot;grapes&quot;}},
  &quot;bananas&quot; #{{:id 1, :name &quot;bananas&quot;}},
  &quot;tomatoes&quot; #{{:id 3, :name &quot;tomatoes&quot;, :colour &quot;red&quot;}}},
 :id
 {1 {:id 1, :name &quot;bananas&quot;},
  2 {:id 2, :name &quot;grapes&quot;},
  3 {:id 3, :name &quot;tomatoes&quot;, :colour &quot;red&quot;}}}</code></pre></div><div><span id="custom"></span><h3>4.4 &nbsp;&nbsp; Custom</h3></div><div><p>Custom conflict behaviour can also be defined. This is covered in the extension section.</p></div><div><span id="Extension"></span><h2><b>5 &nbsp;&nbsp; Extension</b></h2></div><div><span id="custom-keys"></span><h3>5.1 &nbsp;&nbsp; Custom keys</h3></div><div><p>We want to index our fruit by an SKU, which is a string composite of the first letter of the category (capitalized) and the id padded with 3 zeroes (not really, but just imagine)</p></div><div><p>To do this, first implement the <code>compound.custom-key/custom-key-fn</code> multimethod to tell compound how to form the key from the item.</p></div><div class="code"><pre><code class="clojure">(require '[compound.custom-key :as cu])
(require '[clojure.string :as string])

(defmethod cu/custom-key-fn :sku
  [_ item]
  (let [{:keys [category id]} item]
    (str (string/upper-case (first category)) (format &quot;%03d&quot; id))))</code></pre></div><div><p>And then reference it in the index definition, using <code>:custom-key</code></p></div><div class="code"><pre><code class="clojure">(-&gt; (c/compound {:primary-index-def {:custom-key :sku
                                     :on-conflict :compound/merge}})
    (c/add-items [{:id 1 :name &quot;bananas&quot; :category &quot;Long fruit&quot;}
                  {:id 2 :name &quot;grapes&quot; :category &quot;Small round fruit&quot;}
                  {:id 3 :name &quot;tomatoes&quot; :category &quot;Pretend fruit&quot;}])
    (c/primary-index)) =&gt;

{&quot;S002&quot; {:id 2, :name &quot;grapes&quot;, :category &quot;Small round fruit&quot;},
 &quot;L001&quot; {:id 1, :name &quot;bananas&quot;, :category &quot;Long fruit&quot;},
 &quot;P003&quot; {:id 3, :name &quot;tomatoes&quot;, :category &quot;Pretend fruit&quot;}}</code></pre></div><div><p>The built-in secondary indexes can have a custom keys too. It works the same way.</p></div><div class="code"><pre><code class="clojure">(-&gt; (c/compound {:primary-index-def {:key :id
                                     :on-conflict :compound/merge}
                 :secondary-index-defs [{:custom-key :sku}]})
    (c/add-items [{:id 1 :name &quot;bananas&quot; :category &quot;Long fruit&quot;}
                  {:id 2 :name &quot;grapes&quot; :category &quot;Small round fruit&quot;}
                  {:id 3 :name &quot;tomatoes&quot; :category &quot;Pretend fruit&quot;}])
    (c/index :sku)) =&gt;

{&quot;S002&quot; #{{:id 2, :name &quot;grapes&quot;, :category &quot;Small round fruit&quot;}},
 &quot;L001&quot; #{{:id 1, :name &quot;bananas&quot;, :category &quot;Long fruit&quot;}},
 &quot;P003&quot; #{{:id 3, :name &quot;tomatoes&quot;, :category &quot;Pretend fruit&quot;}}}</code></pre></div><div><span id="custom-conflict"></span><h3>5.2 &nbsp;&nbsp; Custom conflict behaviour</h3></div><div><p>If the provided conflict behaviours aren't sufficient, override the <code>compound.core/on-conflict-fn</code> multimethod, to tell compound what to do when two items with the same key are found.</p></div><div class="code"><pre><code class="clojure">(defmethod c/on-conflict-fn :add-quantities
  [_ a b]
  (merge a b {:quantity (+ (get a :quantity) (get b :quantity))}))</code></pre></div><div><p>Using custom conflict behaviour to add quantities, we can do this:</p></div><div class="code"><pre><code class="clojure">(-&gt; (c/compound {:primary-index-def {:key :id
                                     :on-conflict :add-quantities}})
    (c/add-items [{:id 1 :name &quot;bananas&quot; :category &quot;Long fruit&quot; :quantity 1}
                  {:id 1 :name &quot;bananas&quot; :category &quot;Long fruit&quot; :quantity 3}
                  {:id 2 :name &quot;grapes&quot; :category &quot;Small round fruit&quot; :quantity 4}
                  {:id 2 :name &quot;grapes&quot; :category &quot;Small round fruit&quot; :quantity 10}])
    (c/index :id)) =&gt;

{1 {:id 1, :name &quot;bananas&quot;, :category &quot;Long fruit&quot;, :quantity 4},
 2 {:id 2, :name &quot;grapes&quot;, :category &quot;Small round fruit&quot;, :quantity 14}}</code></pre></div><div><span id="custom-indexes"></span><h3>5.3 &nbsp;&nbsp; Custom indexes</h3></div><div><p>Compound can be extended with completely custom indexes, for example if you know of a data structure that provides optimized access for the access pattern that you will use e.g. one of <a href='https://github.com/michalmarczyk'>Michal Marczyk's</a> excellent data structures</p></div><div><p>To extend, implement the following multimethods from the <code>compound.secondary-indexes</code> namespace.</p></div><div><ul><li><code>empty</code> - the initial value of the index</li><li><code>id</code> - to get a unique id from the index definition</li><li><code>add</code> - to add items to the index, called after items are added to the primary index</li><li><code>remove</code> - to remove items from the index, called when items are removed from the primary index</li><li><code>spec</code> - the spec for the index definition</li></ul></div><div><p>To implement a custom index that indexes <em>all</em> attributes of a map</p></div><div class="code"><pre><code class="clojure">(require '[compound.secondary-indexes :as csi])
(require '[clojure.spec.alpha :as s])</code></pre></div><div><p>Add a spec</p></div><div class="code"><pre><code class="clojure">(s/def ::id keyword?)

(defmethod csi/spec :all
  [_]
  (s/keys :opt-un [::id]))</code></pre></div><div><p>The id for the index is the provided id, or <code>:all</code></p></div><div class="code"><pre><code class="clojure">(defmethod csi/id :all
  [index-def]
  (or (get index-def :id) :all))</code></pre></div><div><p>The index will start empty as a plain map</p></div><div class="code"><pre><code class="clojure">(defmethod csi/empty :all
  [index-def]
  {})</code></pre></div><div><p>When items are added to primary index, store them in the index against every attribute</p></div><div class="code"><pre><code class="clojure">(defmethod csi/add :all
  [index index-def added]
  (reduce
    (fn add-item [index item]
      (reduce-kv (fn add-attribute [index k v]
                   (update-in index [k v] (fnil conj #{}) item))
                 index
                 item))
    index
    added))</code></pre></div><div><p>When items are removed from the primary index, remove them against every attribute</p></div><div class="code"><pre><code class="clojure">(defmethod csi/remove :all
  [index index-def removed]
  (reduce
    (fn remove-item [index item]
      (reduce-kv (fn remove-attribute [index k v]
                   (let [existing-items (get-in index [k v])
                         new-items (disj existing-items item)]
                     (if (empty? new-items)
                       (update index k dissoc v)
                       (assoc-in index [k v] new-items))))
                 index
                 item))
    index
    removed))</code></pre></div><div><p>Now we're ready to rock and roll. </p></div><div class="code"><pre><code class="clojure">(-&gt; (c/compound {:primary-index-def {:key :id
                                     :on-conflict :compound/replace}
                 :secondary-index-defs [{:index-type :all}]})
    (c/add-items [{:id 1 :name &quot;bananas&quot;
                   :category &quot;Long fruit&quot;
                   :quantity 1
                   :ripe? true}
                  {:id 2
                   :name &quot;grapes&quot;
                   :category &quot;Small round fruit&quot;
                   :quantity 4
                   :variety :pinot-grigio}
                  {:id 3
                   :name &quot;oranges&quot;
                   :category &quot;Medium round fruit&quot;
                   :ripe? true
                   :quantity 4}])
    (c/remove-keys [1])
    (c/index :all)
    (get-in [:ripe? true])) =&gt;

#{{:id 3,
   :name &quot;oranges&quot;,
   :category &quot;Medium round fruit&quot;,
   :ripe? true,
   :quantity 4}}</code></pre></div><div><span id="miscellaneous"></span><h2><b>6 &nbsp;&nbsp; Miscellaneous</b></h2></div><div><span id="paths-as-keys"></span><h3>6.1 &nbsp;&nbsp; Paths as keys</h3></div><div><p>The primary index and built in secondary indexes support using paths as keys. This is helpful if you have a set of nested structures and want to use a nested value as a key or part of one.</p></div><div class="code"><pre><code class="clojure">(-&gt; (c/compound {:primary-index-def {:key [:product :id]}})
    (c/add-items [{:product {:id 3
                              :name &quot;apples&quot;}
                   :quantity 4}
                  {:product {:id 4
                             :name &quot;bananans&quot;}
                   :quantity 500}])) =&gt;
{:primary-index-def {:on-conflict :compound/replace, :key [:product :id]},
 :primary-index
 {3 {:product {:id 3, :name &quot;apples&quot;}, :quantity 4},
  4 {:product {:id 4, :name &quot;bananans&quot;}, :quantity 500}},
 :secondary-indexes-by-id {},
 :secondary-index-defs-by-id {}}</code></pre></div><div class="code"><pre><code class="clojure">(-&gt; (c/compound {:primary-index-def {:key [:product :id]}
                 :secondary-index-defs [{:keys [[:product :id] :delivery-date]
                                         :id :products-on-date
                                         :index-type :compound/one-to-one-composite}]})
    (c/add-items [{:product {:id 3
                             :name &quot;apples&quot;}
                   :delivery-date &quot;1964-04-01&quot;
                   :quantity 4}
                  {:product {:id 4
                             :name &quot;bananans&quot;}
                   :delivery-date &quot;1964-04-01&quot;
                   :quantity 500}
                  {:product {:id 4
                             :name &quot;cherries&quot;}
                   :delivery-date &quot;1964-04-02&quot;
                   :quantity 6}])) =&gt;
{:primary-index-def {:on-conflict :compound/replace, :key [:product :id]},
 :primary-index
 {3
  {:product {:id 3, :name &quot;apples&quot;}, :delivery-date &quot;1964-04-01&quot;, :quantity 4},
  4
  {:product {:id 4, :name &quot;cherries&quot;},
   :delivery-date &quot;1964-04-02&quot;,
   :quantity 6}},
 :secondary-indexes-by-id
 {:products-on-date
  {4
   {&quot;1964-04-02&quot;
    {:product {:id 4, :name &quot;cherries&quot;},
     :delivery-date &quot;1964-04-02&quot;,
     :quantity 6}},
   3
   {&quot;1964-04-01&quot;
    {:product {:id 3, :name &quot;apples&quot;},
     :delivery-date &quot;1964-04-01&quot;,
     :quantity 4}}}},
 :secondary-index-defs-by-id
 {:products-on-date
  {:index-type :compound/one-to-one-composite,
   :keys [[:product :id] :delivery-date],
   :id :products-on-date}}}</code></pre></div><div><span id="diffing"></span><h3>6.2 &nbsp;&nbsp; Diffing</h3></div><div><p>Some utility functions are provided to help diffing compounds. This is useful if you have two sources of data which you need to synchronize, e.g. client and server state</p></div><div class="code"><pre><code class="clojure">(c/diff (-&gt; (c/compound {:primary-index-def {:key :id}})
            (c/add-items [{:id 1 :name &quot;bananas&quot; :category &quot;Old fruit&quot;}
                          {:id 2 :name &quot;grapes&quot; :category &quot;New fruit&quot;}
                          {:id 4 :name &quot;strawberries&quot; :category &quot;Red fruit&quot;}
                          {:id 5 :name &quot;blueberries&quot; :category &quot;Blue fruit&quot;}]))
        (-&gt; (c/compound {:primary-index-def {:key :id}})
            (c/add-items [{:id 1 :name &quot;bananas&quot; :category &quot;Long fruit&quot;}
                          {:id 2 :name &quot;grapes&quot; :category &quot;Small round fruit&quot;}
                          {:id 3 :name &quot;tomatoes&quot; :category &quot;Pretend fruit&quot;}]))) =&gt;
{:inserts
 #{{:id 5, :name &quot;blueberries&quot;, :category &quot;Blue fruit&quot;}
   {:id 4, :name &quot;strawberries&quot;, :category &quot;Red fruit&quot;}},
 :updates
 #{{:source {:id 2, :name &quot;grapes&quot;, :category &quot;New fruit&quot;},
    :target {:id 2, :name &quot;grapes&quot;, :category &quot;Small round fruit&quot;}}
   {:source {:id 1, :name &quot;bananas&quot;, :category &quot;Old fruit&quot;},
    :target {:id 1, :name &quot;bananas&quot;, :category &quot;Long fruit&quot;}}},
 :deletes #{{:id 3, :name &quot;tomatoes&quot;, :category &quot;Pretend fruit&quot;}}}</code></pre></div><div><span id="experimental-alternate-structure"></span><h3>6.3 &nbsp;&nbsp; (experimental) Alternate structure</h3></div><div><p>You can get a flatter structure for a compound by passing in <code>:structure :compound/flat</code> when creating it. </p></div><div><p>This makes using compounds in maps nicer because you don't have to switch between <code>get</code> and <code>&#40;c/index&#41;</code> and can use <code>get-in</code> all the way through</p></div><div class="code"><pre><code class="clojure">(-&gt; (c/compound {:primary-index-def {:key :id}
                 :secondary-index-defs [{:key :name}
                                        {:key :category}]
                 :structure :compound/flat})
    (c/add-items [{:id 1 :name &quot;bananas&quot; :category &quot;Old fruit&quot;}
                  {:id 2 :name &quot;grapes&quot; :category &quot;New fruit&quot;}
                  {:id 4 :name &quot;strawberries&quot; :category &quot;Red fruit&quot;}
                  {:id 5 :name &quot;blueberries&quot; :category &quot;Blue fruit&quot;}])
    (get-in [:category &quot;Red fruit&quot;]))
=&gt; #{{:id 4, :name &quot;strawberries&quot;, :category &quot;Red fruit&quot;}}</code></pre></div><div class="code"><pre><code class="clojure">(publish/publish-all)</code></pre></div>
        </div>
      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

  </body>

  <script>
  if (false) {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', '<@=tracking>', 'caudate.me');
    ga('send', 'pageview');
  }
  </script>
  
  <script type="text/javascript">
    smoothScroll.init();
    gumshoe.init({});
  
    hljs.registerLanguage("clojure",function(e){var t={"builtin-name":"def defonce cond apply if-not if-let if not not= = < > <= >= == + / * - rem quot neg? pos? delay? symbol? keyword? true? false? integer? empty? coll? list? set? ifn? fn? associative? sequential? sorted? counted? reversible? number? decimal? class? distinct? isa? float? rational? reduced? ratio? odd? even? char? seq? vector? string? map? nil? contains? zero? instance? not-every? not-any? libspec? -> ->> .. . inc compare do dotimes mapcat take remove take-while drop letfn drop-last take-last drop-while while intern condp case reduced cycle split-at split-with repeat replicate iterate range merge zipmap declare line-seq sort comparator sort-by dorun doall nthnext nthrest partition eval doseq await await-for let agent atom send send-off release-pending-sends add-watch mapv filterv remove-watch agent-error restart-agent set-error-handler error-handler set-error-mode! error-mode shutdown-agents quote var fn loop recur throw try monitor-enter monitor-exit defmacro defn defn- macroexpand macroexpand-1 for dosync and or when when-not when-let comp juxt partial sequence memoize constantly complement identity assert peek pop doto proxy defstruct first rest cons defprotocol cast coll deftype defrecord last butlast sigs reify second ffirst fnext nfirst nnext defmulti defmethod meta with-meta ns in-ns create-ns import refer keys select-keys vals key val rseq name namespace promise into transient persistent! conj! assoc! dissoc! pop! disj! use class type num float double short byte boolean bigint biginteger bigdec print-method print-dup throw-if printf format load compile get-in update-in pr pr-on newline flush read slurp read-line subvec with-open memfn time re-find re-groups rand-int rand mod locking assert-valid-fdecl alias resolve ref deref refset swap! reset! set-validator! compare-and-set! alter-meta! reset-meta! commute get-validator alter ref-set ref-history-count ref-min-history ref-max-history ensure sync io! new next conj set! to-array future future-call into-array aset gen-class reduce map filter find empty hash-map hash-set sorted-map sorted-map-by sorted-set sorted-set-by vec vector seq flatten reverse assoc dissoc list disj get union difference intersection extend extend-type extend-protocol int nth delay count concat chunk chunk-buffer chunk-append chunk-first chunk-rest max min dec unchecked-inc-int unchecked-inc unchecked-dec-inc unchecked-dec unchecked-negate unchecked-add-int unchecked-add unchecked-subtract-int unchecked-subtract chunk-next chunk-cons chunked-seq? prn vary-meta lazy-seq spread list* str find-keyword keyword symbol gensym force rationalize"},r="a-zA-Z_\\-!.?+*=<>&#'",n="["+r+"]["+r+"0-9/;:]*",a="[-+]?\\d+(\\.\\d+)?",o={b:n,r:0},s={cN:"number",b:a,r:0},i=e.inherit(e.QSM,{i:null}),c=e.C(";","$",{r:0}),d={cN:"literal",b:/\b(true|false|nil)\b/},l={b:"[\\[\\{]",e:"[\\]\\}]"},m={cN:"comment",b:"\\^"+n},p=e.C("\\^\\{","\\}"),u={cN:"symbol",b:"[:]{1,2}"+n},f={b:"\\(",e:"\\)"},h={eW:!0,r:0},y={k:t,l:n,cN:"name",b:n,starts:h},b=[f,i,m,p,c,u,l,s,d,o];return f.c=[e.C("comment",""),y,h],h.c=b,l.c=b,{aliases:["clj"],i:/\S/,c:[f,i,m,p,c,u,l,s,d]}});
    hljs.initHighlightingOnLoad();
  </script>
</html>
